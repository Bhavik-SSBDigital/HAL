generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Department {
  id                 Int          @id @default(autoincrement())
  type               String
  code               String       @unique
  name               String       @unique
  status             String
  headId             Int?
  adminId            Int?
  parentDepartmentId Int?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime?    @updatedAt
  createdById        Int
  head               User?        @relation("HeadOfDepartment", fields: [headId], references: [id])
  admin              User?        @relation("AdminOfDepartment", fields: [adminId], references: [id])
  parentDepartment   Department?  @relation("ParentDepartment", fields: [parentDepartmentId], references: [id])
  subDepartments     Department[] @relation("ParentDepartment")
  documents          Document[]
  roles              Role[]       @relation("BranchRoles")
  users              User[]       @relation("BranchUsers")
  DepartmentRoleAssignment DepartmentRoleAssignment[]
  // Added back relation
  departmentStepProgresses DepartmentStepProgress[] @relation()
  documentAccesses DocumentAccess[] @relation()
}

model Document {
  id                      Int          @id @default(autoincrement())
  name                    String
  type                    String
  path                    String       @unique
  createdById             Int
  createdOn               DateTime     @default(now())
  lastUpdatedOn           DateTime     @updatedAt
  children                Document[]   @relation("DocumentChildren")
  parent                  Document?    @relation("DocumentChildren", fields: [parentId], references: [id])
  parentId                Int?
  departmentId            Int?
  department              Department?  @relation(fields: [departmentId], references: [id])
  isProject               Boolean?
  isInvolvedInProcess     Boolean      @default(false)
  minimumSignsOnFirstPage Int?
  isRejected              Boolean      @default(false)
  tags                    String[]     @default([])
  processDocuments        ProcessDocument[]
  documentAccesses        DocumentAccess[] @relation("DocumentAccesses")
  isRecord                Boolean  @default(true)
  recommendationHighlights RecommendationDocumentHighlight[]
  queryDocuments ProcessQueryDocument[]
  queryReferences QueryDocumentReference[]
  highlights DocumentHighlight[]
  querySummaries QueryDocumentSummary[]
  recommendationSummaries RecommendationDocumentSummary[]
}

model Role {
  id                  Int         @id @default(autoincrement())
  departmentId        Int?
  status              String
  role                String
  isRootLevel         Boolean     @default(false)
  isAdmin             Boolean     @default(false)
  isActive            Boolean     @default(true)
  parentRoleId        Int?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime?   @updatedAt
  branch              Department? @relation("BranchRoles", fields: [departmentId], references: [id])
  parentRole          Role?       @relation("RoleHierarchy", fields: [parentRoleId], references: [id])
  childRoles          Role[]      @relation("RoleHierarchy")
  users               UserRole[]
  departmentRoleAssignment DepartmentRoleAssignment[]
  documentAccesses DocumentAccess[] @relation()
}

model User {
  id                 Int           @id @default(autoincrement())
  username           String        @unique
  email              String        
  password           String
  name               String?
  specialUser        Boolean       @default(false)
  createdAt          DateTime      @default(now())
  isRootLevel        Boolean?
  isAdmin            Boolean?
  tokens             Token[]
  updatedAt          DateTime?     @updatedAt
  createdById        Int?
  createdBy          User?         @relation("CreatedByRelation", fields: [createdById], references: [id])
  createdUsers       User[]        @relation("CreatedByRelation")
  roles              UserRole[]
  branches           Department[]  @relation("BranchUsers")
  headOfDepartments  Department[]  @relation("HeadOfDepartment")
  adminOfDepartments Department[]  @relation("AdminOfDepartment")
  workflowsCreated   Workflow[]
  initiatedProcesses ProcessInstance[]
  qaInitiations      ProcessQA[]
  processNotifications ProcessNotification[] @relation("UserNotifications")
  processClaims        ProcessClaim[]        @relation("UserClaims")
  systemLogs           SystemLog[]           @relation("UserSystemLogs")
  pickedProcessSteps   ProcessStepInstance[] @relation("UserPickedSteps")
  rejectedProcessDocuments ProcessDocument[] @relation("RejectedByUser")
  signatures         DocumentSignature[] @relation("UserSignatures")
  signaturePicFileName String?
  signCoordinates    SignCoordinate[] @relation
  documentAccesses DocumentAccess[] @relation()
  grantedDocumentAccesses DocumentAccess[] @relation("GrantedByUser")
  recommendationsRequested ProcessRecommendation[] @relation("RecommendationRequestedBy")
  recommendationsReceived ProcessRecommendation[] @relation("RecommendationRecommendedTo")
  queryResponses ProcessQueryResponse[]
  queryDocuments ProcessQueryDocument[]
  queryApprovals QueryDocumentApproval[]
  recirculationApprovals QueryRecirculationApproval[]
  doubtsRaised QueryDoubt[]
  doubtResponses QueryDoubtResponse[]
  documentHighlights DocumentHighlight[]
  // Added opposite relations
  recommendationResponses RecommendationResponse[] @relation("RecommendationRespondedBy")
  queriesRaised ProcessQuery[] @relation("QueriesRaisedBy")
}

model Token {
  id     Int    @id @default(autoincrement())
  token  String
  userId Int
  user   User   @relation(fields: [userId], references: [id])

  @@unique([userId])
}

model UserRole {
  id     Int  @id @default(autoincrement())
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id])
  role   Role @relation(fields: [roleId], references: [id])
}

model Workflow {
  id                 String        @id @default(uuid())
  name               String
  description        String?
  version            Int           @default(1)
  previousVersionId  String?
  previousVersion    Workflow?     @relation("WorkflowVersion", fields: [previousVersionId], references: [id])
  createdById        Int
  createdBy          User          @relation(fields: [createdById], references: [id])
  isActive           Boolean       @default(true)
  steps              WorkflowStep[]
  processes          ProcessInstance[]
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  nextVersions       Workflow[]    @relation("WorkflowVersion")
  escalationTime     Int?          @default(48)
  autoApprovalAfter  Int?          @default(168)
}

model WorkflowStep {
  id                  String         @id @default(uuid())
  workflowId          String
  workflow            Workflow       @relation(fields: [workflowId], references: [id])
  stepNumber          Int
  stepName            String
  stepType            StepType       @default(APPROVAL)
  allowParallel       Boolean        @default(false)
  isHierarchical      Boolean        @default(false)
  direction           String?        @default("downwards")
  selectedRoles       Int[]          @default([])
  assignments         WorkflowAssignment[]
  processSteps        ProcessStepInstance[]
  escalationTime      Int?           @default(24)
  autoApprovalAfter   Int?           @default(72)
  requiresDocument    Boolean        @default(true)
  currentStepProcessInstances ProcessInstance[] @relation("CurrentStepRelation")
  departmentStepProgresses DepartmentStepProgress[] // Added back relation
  signCoordinates     SignCoordinate[] @relation // Added opposite relation
  @@unique([workflowId, stepNumber])
}

enum StepType {
  APPROVAL
  REVIEW
  RECOMMENDATION
  NOTIFICATION
}

enum ApproverType {
  USER
  ROLE
  DEPARTMENT
  UNIT
}


enum Direction {
  UPWARDS   // Document flows from lower to higher roles
  DOWNWARDS // Document flows from higher to lower roles
}


model WorkflowAssignment {
  id                String   @id @default(uuid())
  stepId            String
  step              WorkflowStep @relation(fields: [stepId], references: [id])
  actionType        ActionType
  assigneeIds       Int[]
  assigneeType      AssigneeType
  departmentRoles   DepartmentRoleAssignment[]
  accessTypes       AccessType[] @default([])
  direction         Direction?   // Document flow direction for these roles
  allowParallel     Boolean @default(false)
  documentAccesses  DocumentAccess[] @relation("WorkflowAssignmentDocAccess")
  // Added back relations
  stepInstances     ProcessStepInstance[]
  assignmentProgresses AssignmentProgress[]
}


model DepartmentRoleAssignment {
  id                   Int              @id @default(autoincrement())
  workflowAssignment   WorkflowAssignment @relation(fields: [workflowAssignmentId], references: [id])
  workflowAssignmentId String
  department           Department       @relation(fields: [departmentId], references: [id])
  departmentId         Int
  role                 Role             @relation(fields: [roleId], references: [id])
  roleId               Int

  // Enforce unique combination of assignment-department-role
  @@unique([workflowAssignmentId, departmentId, roleId])
}

model ProcessWorkflowVersion {
  id          String   @id @default(uuid())
  processId   String
  oldVersion  Int
  newVersion  Int
  migratedAt  DateTime @default(now())
}

model DocumentAccess {
  id                 String   @id @default(uuid())
  documentId         Int
  document           Document @relation("DocumentAccesses", fields: [documentId], references: [id])
  stepInstanceId     String?
  stepInstance       ProcessStepInstance? @relation("StepInstanceDocumentAccess", fields: [stepInstanceId], references: [id])
  accessType         AccessType[] @default([])
  accessLevel        AccessLevel  @default(STANDARD) 
  processInstance    ProcessInstance? @relation(fields: [processId], references: [id])
  assignmentId       String?  
  assignment         WorkflowAssignment? @relation("WorkflowAssignmentDocAccess", fields: [assignmentId], references: [id])
  processId          String?
  userId             Int?
  user               User?        @relation(fields: [userId], references: [id])
  roleId             Int?
  role               Role?        @relation(fields: [roleId], references: [id])
  departmentId       Int?
  department         Department?  @relation(fields: [departmentId], references: [id])
  grantedAt          DateTime     @default(now())
  grantedById        Int?        
  grantedBy          User?        @relation("GrantedByUser", fields: [grantedById], references: [id])
  docAccessThrough   DocAccessThrough @default(SELF)
}


enum AccessLevel{
  STANDARD
  FULL
}

enum DocAccessThrough{
  PROCESS
  ADMINISTRATION
  SELF
}

enum NotificationType {
  STEP_ASSIGNMENT
  QUERY
  QUERY_RESPONSE
  DOCUMENT_UPLOAD
  DOCUMENT_APPROVAL
  PROCESS_COMPLETION
  RECOMMENDATION_REQUEST
  RECOMMENDATION_COMPLETE
  RECIRCULATION_REQUEST
  RECIRCULATION_APPROVAL
  QUERY_DOUBT
  QUERY_DOUBT_RESPONSE
  RECOMMENDATION_CLARIFICATION_REQUEST
  RECOMMENDATION_CLARIFICATION_RESPONSE
}


model ProcessNotification {
  id        String   @id @default(uuid())
  stepId    String?
  stepInstance ProcessStepInstance? @relation("StepInstanceNotifications", fields: [stepId], references: [id])
  userId    Int
  user      User @relation("UserNotifications", fields: [userId], references: [id])
  notifiedAt DateTime @default(now())
  removedAt DateTime?
  status    String @default("ACTIVE")
   type        NotificationType
  recommendation ProcessRecommendation? @relation(fields: [recommendationId], references: [id])
  recommendationId String?
  query       ProcessQuery? @relation(fields: [queryId], references: [id])
  queryId     String?
  readAt      DateTime?
  metadata    Json?
}

model ProcessClaim {
  id        String   @id @default(uuid())
  stepId    String
  userId    Int
  user      User @relation("UserClaims", fields: [userId], references: [id])
  claimedAt DateTime @default(now())
}

model SystemLog {
  id        String   @id @default(uuid())
  userId    Int?
  user      User?    @relation("UserSystemLogs", fields: [userId], references: [id])
  action    String
  details   Json?
  timestamp DateTime @default(now())
}

enum AccessType {
  READ
  EDIT
  DOWNLOAD
}

enum AssigneeType {
  USER
  ROLE
  DEPARTMENT
  UNIT
}

enum ActionType {
  APPROVAL
  REVIEW
  RECOMMENDATION
  NOTIFICATION
}

model ProcessInstance {
  id             String   @id @default(uuid())
  name           String
  workflowId     String
  workflow       Workflow @relation(fields: [workflowId], references: [id])
  initiatorId    Int
  initiator      User     @relation(fields: [initiatorId], references: [id])
  currentStepId  String?
  currentStep    WorkflowStep? @relation("CurrentStepRelation", fields: [currentStepId], references: [id])
  status         ProcessStatus @default(PENDING)
  customizations Json?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime? @updatedAt
  stepInstances  ProcessStepInstance[]
  documents      ProcessDocument[]
  qaChannels     ProcessQA[]
  trackings      ProcessTracking[]
  documentAccess DocumentAccess[]
  // Added relations
  assignmentProgresses AssignmentProgress[] @relation()
  departmentStepProgresses DepartmentStepProgress[] @relation()
  recommendations ProcessRecommendation[]
  queries ProcessQuery[]
}

enum ProcessStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REJECTED
}

model AssignmentProgress {
  id                  String                 @id @default(uuid())
  workflowAssignment  WorkflowAssignment    @relation(fields: [assignmentId], references: [id])
  assignmentId        String
  process             ProcessInstance       @relation(fields: [processId], references: [id])
  processId           String
  currentLevel        Int?
  roleHierarchy       Json? // [[role1], [role2,role3], ...] for hierarchical flow
  completed           Boolean               @default(false)
  completedAt         DateTime?
  stepInstances       ProcessStepInstance[]
  completedRoles      Int[]     @default([])
  
  departmentStepProgress DepartmentStepProgress? @relation("DepartmentAssignmentProgress")
  
  @@unique([assignmentId, processId])
}

model ProcessStepInstance {
  id                   String       @id @default(uuid())
  process              ProcessInstance @relation(fields: [processId], references: [id])
  processId            String
  workflowAssignment   WorkflowAssignment? @relation(fields: [assignmentId], references: [id])
  assignmentId         String?
  assignmentProgress   AssignmentProgress? @relation(fields: [progressId], references: [id])
  progressId           String?
  assignedTo           Int
  roleId               Int?
  departmentId         Int?
  status               StepStatus   @default(PENDING)
  claimedAt            DateTime?
  deadline             DateTime?
  // Added relations
  pickedBy             User?        @relation(fields: [pickedById], references: [id], name: "UserPickedSteps")
  pickedById           Int?  
  createdAt            DateTime @default(now())
  queries ProcessQuery[]
  workflowStep         WorkflowStep? @relation(fields: [stepId], references: [id])
  stepId       String?
  documentAccesses     DocumentAccess[] @relation("StepInstanceDocumentAccess")
  notifications        ProcessNotification[] @relation("StepInstanceNotifications")
  escalations          Escalation[]
  qaChannels           ProcessQA[] @relation("StepInstanceQA")
  decisionComment     String?
  decisionAt          DateTime?
  isRecirculated         Boolean @default(false)
  originalStepInstanceId String?  // For tracking recirculated steps
  recirculationReason    String?
  @@index([assignmentId])
}

enum StepStatus {
  PENDING
  APPROVED
  REJECTED
  SKIPPED
  IN_PROGRESS
   ESCALATED
}

model Escalation {
  id             String   @id @default(uuid())
  stepInstanceId String
  stepInstance   ProcessStepInstance @relation(fields: [stepInstanceId], references: [id])
  escalationType EscalationType
  triggerTime    DateTime
  status         EscalationStatus @default(PENDING)
}

enum EscalationType {
  REMINDER
  ESCALATION
  AUTO_APPROVAL
}

enum EscalationStatus {
  PENDING
  TRIGGERED
  COMPLETED
}

model ProcessTracking {
  id         String   @id @default(uuid())
  processId  String
  process    ProcessInstance @relation(fields: [processId], references: [id])
  userId     Int
  actionType ActionType
  timestamp  DateTime @default(now())
}

model ProcessDocument {
  id              String   @id @default(uuid())
  processId       String
  process         ProcessInstance @relation(fields: [processId], references: [id])
  documentId      Int
  document        Document @relation(fields: [documentId], references: [id])
  signatures      DocumentSignature[]
  rejectedById    Int?
  rejectionReason String?
  rejectedAt      DateTime?
  rejectedBy      User?    @relation("RejectedByUser", fields: [rejectedById], references: [id])  // Single field
  signCoordinates SignCoordinate[] @relation
}

model DocumentSignature {
  id                String           @id @default(uuid())
  processDocument   ProcessDocument  @relation(fields: [processDocumentId], references: [id])
  processDocumentId String
  userId            Int
  user              User             @relation("UserSignatures", fields: [userId], references: [id])  // Single field
  reason            String?
  signedAt          DateTime         @default(now())
}

model ProcessQA {
  id            String   @id @default(uuid())
  processId     String
  process       ProcessInstance @relation(fields: [processId], references: [id])
  stepInstanceId String
  stepInstance  ProcessStepInstance @relation("StepInstanceQA", fields: [stepInstanceId], references: [id])  // Single field
  initiatorId   Int
  initiator     User @relation(fields: [initiatorId], references: [id])
  entityId      Int
  entityType    AssigneeType
  question      String
  answer        String?
  createdAt     DateTime @default(now())
  answeredAt    DateTime?
}

model DepartmentStepProgress {
  id                  String              @id @default(uuid())
  process             ProcessInstance     @relation(fields: [processId], references: [id])
  processId           String
  step                WorkflowStep       @relation(fields: [stepId], references: [id])
  stepId              String
  department          Department         @relation(fields: [departmentId], references: [id])
  departmentId        Int
  roleLevels          Json               // Stores array of role ID arrays representing hierarchy levels
  currentLevel        Int                // Current level being processed
  isCompleted         Boolean            @default(false)
  direction           Direction
  completedRoles      Int[]              @default([])
  requiredRoles       Int[]              // [6,7,8,9] for your example
  
  assignmentProgress  AssignmentProgress? @relation(name: "DepartmentAssignmentProgress", fields: [assignmentProgressId], references: [id])
  assignmentProgressId String?            @unique
  
  @@unique([processId, stepId, departmentId])
}

model SignCoordinate {
  id                String   @id @default(uuid())
  processDocumentId String
  processDocument   ProcessDocument @relation(fields: [processDocumentId], references: [id])
  page              Int
  x                 Float
  y                 Float
  width             Float
  height            Float
  stepId            String?
  step              WorkflowStep? @relation(fields: [stepId], references: [id])
  isSigned          Boolean  @default(false)
  signedById        Int?
  signedBy          User?    @relation(fields: [signedById], references: [id])
  createdAt         DateTime @default(now())
}


// ========== RECOMMENDATION MODELS ==========
model ProcessRecommendation {
  id            String     @id @default(uuid())
  process       ProcessInstance @relation(fields: [processId], references: [id])
  processId     String
  requestedById Int
  requestedBy   User       @relation("RecommendationRequestedBy", fields: [requestedById], references: [id])
  recommendedToId Int
  recommendedTo User       @relation("RecommendationRecommendedTo", fields: [recommendedToId], references: [id])
  status        RecommendationStatus @default(PENDING)
  remarks       String?
  createdAt     DateTime   @default(now())
  completedAt   DateTime?
  highlights    RecommendationDocumentHighlight[]
  responses     RecommendationResponse[]
  documentSummaries RecommendationDocumentSummary[]
  processSummary    RecommendationSummary?
  notifications ProcessNotification[]
  // Added opposite relation
  documentHighlights DocumentHighlight[] @relation("RecommendationHighlights")
}

model RecommendationDocumentHighlight {
  id              String     @id @default(uuid())
  recommendation  ProcessRecommendation @relation(fields: [recommendationId], references: [id])
  recommendationId String
  document        Document   @relation(fields: [documentId], references: [id])
  documentId      Int
  pageNumber      Int
  coordinates     Json       // {x, y, width, height}
  comments        String?
  createdAt       DateTime   @default(now())
}

model RecommendationResponse {
  id              String     @id @default(uuid())
  recommendation  ProcessRecommendation @relation(fields: [recommendationId], references: [id])
  recommendationId String
  respondedById   Int
  respondedBy     User       @relation("RecommendationRespondedBy", fields: [respondedById], references: [id])
  responseText    String
  createdAt       DateTime   @default(now())
  // Added opposite relation
  documentHighlights DocumentHighlight[] @relation("RecommendationResponseHighlights")
}

enum RecommendationStatus {
  PENDING
  COMPLETED
  REJECTED
  CLARIFICATION_REQUESTED
}

// ========== QUERY MODELS ==========
model ProcessQuery {
  id                String     @id @default(uuid())
  process           ProcessInstance @relation(fields: [processId], references: [id])
  processId         String
  stepInstance      ProcessStepInstance? @relation(fields: [stepInstanceId], references: [id])
  stepInstanceId    String?
  raisedById        Int
  raisedBy          User       @relation("QueriesRaisedBy", fields: [raisedById], references: [id])
  queryText         String
  status            QueryStatus @default(OPEN)
  createdAt         DateTime   @default(now())
  resolvedAt        DateTime?
  responses         ProcessQueryResponse[]
  documents         ProcessQueryDocument[]
  recirculationFromStepId String?
  recirculationApprovals QueryRecirculationApproval[]
  doubts            QueryDoubt[]
  documentSummaries QueryDocumentSummary[]
  processSummary    ProcessQuerySummary?
  notifications ProcessNotification[]
  highlights DocumentHighlight[]
}

model ProcessQueryResponse {
  id              String     @id @default(uuid())
  query           ProcessQuery @relation(fields: [queryId], references: [id])
  queryId         String
  respondedById   Int
  respondedBy     User       @relation(fields: [respondedById], references: [id])
  responseText    String
  createdAt       DateTime   @default(now())
  documentRefs    QueryDocumentReference[]
  highlights DocumentHighlight[]
}

model ProcessQueryDocument {
  id              String     @id @default(uuid())
  query           ProcessQuery @relation(fields: [queryId], references: [id])
  queryId         String
  document        Document   @relation(fields: [documentId], references: [id])
  documentId      Int
  uploadedById    Int
  uploadedBy      User       @relation(fields: [uploadedById], references: [id])
  requiresApproval Boolean   @default(true)
  isReplacement   Boolean   @default(false)
  replacesDocumentId Int?
  approvals       QueryDocumentApproval[]
  createdAt       DateTime   @default(now())
}

model QueryDocumentApproval {
  id              String     @id @default(uuid())
  queryDocument   ProcessQueryDocument @relation(fields: [queryDocumentId], references: [id])
  queryDocumentId String
  approverId      Int
  approver        User       @relation(fields: [approverId], references: [id])
  approved        Boolean
  comments        String?
  approvedAt      DateTime?
}

model QueryDocumentReference {
  id              String     @id @default(uuid())
  response        ProcessQueryResponse @relation(fields: [responseId], references: [id])
  responseId      String
  document        Document   @relation(fields: [documentId], references: [id])
  documentId      Int
  pageNumber      Int?
  coordinates     Json?      // {x, y, width, height} for highlighting
  comments        String?
}

model QueryRecirculationApproval {
  id              String     @id @default(uuid())
  query           ProcessQuery @relation(fields: [queryId], references: [id])
  queryId         String
  approverId      Int
  approver        User       @relation(fields: [approverId], references: [id])
  approved        Boolean
  comments        String?
  approvedAt      DateTime?
}

enum QueryStatus {
  OPEN
  RESOLVED
  REJECTED
  RECIRCULATION_PENDING
}

model DocumentHighlight {
  id          String   @id @default(uuid())
  documentId  Int
  document    Document @relation(fields: [documentId], references: [id])
  coordinates Json
  remark      String?
  createdAt   DateTime @default(now())
  createdById Int
  createdBy   User     @relation(fields: [createdById], references: [id])
  queryId             String?
  query               ProcessQuery?             @relation(fields: [queryId], references: [id])
  queryResponseId     String?
  queryResponse       ProcessQueryResponse?     @relation(fields: [queryResponseId], references: [id])
  queryDoubtId        String?
  queryDoubt          QueryDoubt?              @relation(fields: [queryDoubtId], references: [id])
  recommendationId    String?
  recommendation      ProcessRecommendation?    @relation("RecommendationHighlights", fields: [recommendationId], references: [id])
  recommendationResponseId String?
  recommendationResponse   RecommendationResponse? @relation("RecommendationResponseHighlights", fields: [recommendationResponseId], references: [id])
  @@index([documentId])
  @@index([queryId])
  @@index([queryResponseId])
  @@index([queryDoubtId])
  @@index([recommendationId])
  @@index([recommendationResponseId])
}

model QueryDoubt {
  id          String   @id @default(uuid())
  queryId     String
  query       ProcessQuery @relation(fields: [queryId], references: [id])
  raisedById  Int
  raisedBy    User     @relation(fields: [raisedById], references: [id])
  doubtText   String
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  responses   QueryDoubtResponse[]
  highlights DocumentHighlight[]
}


model QueryDoubtResponse {
  id          String   @id @default(uuid())
  doubtId     String
  doubt       QueryDoubt @relation(fields: [doubtId], references: [id])
  respondedById Int
  respondedBy User     @relation(fields: [respondedById], references: [id])
  responseText String
  createdAt   DateTime @default(now())
}

model QueryDocumentSummary {
  id          String   @id @default(uuid())
  queryId     String
  query       ProcessQuery @relation(fields: [queryId], references: [id])
  documentId  Int
  document    Document @relation(fields: [documentId], references: [id])
  summaryText String
  createdAt   DateTime @default(now())
}

model ProcessQuerySummary {
  id          String   @id @default(uuid())
  queryId     String   @unique
  query       ProcessQuery @relation(fields: [queryId], references: [id])
  summaryText String
  createdAt   DateTime @default(now())
}

model RecommendationDocumentSummary {
  id          String   @id @default(uuid())
  recommendationId String
  recommendation ProcessRecommendation @relation(fields: [recommendationId], references: [id])
  documentId  Int
  document    Document @relation(fields: [documentId], references: [id])
  summaryText String
  createdAt   DateTime @default(now())
}

model RecommendationSummary {
  id          String   @id @default(uuid())
  recommendationId String @unique
  recommendation ProcessRecommendation @relation(fields: [recommendationId], references: [id])
  summaryText String
  createdAt   DateTime @default(now())
}
