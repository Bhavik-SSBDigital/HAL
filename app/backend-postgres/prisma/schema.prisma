generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Department {
  id                 Int          @id @default(autoincrement())
  type               String
  code               String         @unique
  name               String       @unique
  status             String
  headId             Int?
  adminId            Int?
  parentDepartmentId Int?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime?    @updatedAt
  createdById        Int
  head               User?        @relation("HeadOfDepartment", fields: [headId], references: [id])
  admin              User?        @relation("AdminOfDepartment", fields: [adminId], references: [id])
  parentDepartment   Department?  @relation("ParentDepartment", fields: [parentDepartmentId], references: [id])
  subDepartments     Department[] @relation("ParentDepartment")
  documents          Document[]
  roles              Role[]       @relation("BranchRoles") // Opposite relation for `Role`
  users              User[]       @relation("BranchUsers") // Opposite relation for `User`
}

model Document {
  id                      Int          @id @default(autoincrement())
  name                    String
  type                    String
  path                    String       @unique
  createdById             Int
  createdOn               DateTime     @default(now())
  lastUpdatedOn           DateTime     @updatedAt
  history                 DocHistory[]
  children                Document[]   @relation("DocumentChildren")
  parent                  Document?    @relation("DocumentChildren", fields: [parentId], references: [id])
  parentId                Int?
  departmentId            Int?
  department              Department?  @relation(fields: [departmentId], references: [id])
  isProject               Boolean?
  isInvolvedInProcess     Boolean      @default(false)
  minimumSignsOnFirstPage Int?
  isRejected              Boolean      @default(false)
  highlights              Highlight[]
}

model Role {
  id                  Int         @id @default(autoincrement())
  departmentId        Int?
  status              String
  role                String
  isRootLevel         Boolean      @default(false) // Indicates if the role is root-level
  parentRoleId        Int?         // Parent role ID for hierarchy
  createdAt           DateTime     @default(now())
  updatedAt           DateTime?    @updatedAt
  branch              Department?  @relation("BranchRoles", fields: [departmentId], references: [id])
  parentRole          Role?        @relation("RoleHierarchy", fields: [parentRoleId], references: [id])
  childRoles          Role[]       @relation("RoleHierarchy")
  users               UserRole[]
  writable            Int[]        @default([])   // IDs of documents writable by the role
  readable            Int[]        @default([])   // IDs of documents readable by the role
  downloadable        Int[]        @default([])   // IDs of documents downloadable by the role
  fullAccessWritable  Int[]        @default([])   // IDs of documents with full writable access
  fullAccessReadable  Int[]        @default([])   // IDs of documents with full readable access
  fullAccessDownloadable Int[]     @default([])   // IDs of documents with full downloadable access
}


model User {
  id                 Int           @id @default(autoincrement())
  username           String        @unique
  email              String        @unique
  password           String
  name               String?
  specialUser        Boolean       @default(false)
  createdAt          DateTime      @default(now())
  isRootLevel        Boolean?      // Optional field
  isAdmin            Boolean?      // Optional field
  tokens             Token[]       // One-to-many relationship: A user can have many tokens
  updatedAt          DateTime?     @updatedAt
  createdById        Int?
  createdBy          User?         @relation("CreatedByRelation", fields: [createdById], references: [id]) // Relation for creator
  createdUsers       User[]        @relation("CreatedByRelation") // Opposite relation for created users
  roles              UserRole[]
  branches           Department[]  @relation("BranchUsers") // Relation with Departments
  headOfDepartments  Department[]  @relation("HeadOfDepartment") // Relation with head of departments
  adminOfDepartments Department[]  @relation("AdminOfDepartment") // Relation with admin of departments
  logs               Log[]         @relation("UserLogs") // Opposite relation for logs
  docHistory         DocHistory[]  @relation("ChangedBy") // Opposite relation for doc history

  // Arrays to store accessible document IDs
  writable    Int[]      // IDs of documents the user can write
  readable    Int[]      // IDs of documents the user can read
  downloadable Int[]     // IDs of documents the user can download
  uploadable  Int[]      // IDs of documents the user can upload
}


model Token {
  id     Int    @id @default(autoincrement())
  token  String
  userId Int
  user   User   @relation(fields: [userId], references: [id])

  @@unique([userId]) // Ensure each user has only one token
}

model UserRole {
  id     Int  @id @default(autoincrement())
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id])
  role   Role @relation(fields: [roleId], references: [id])
}


model Workflow {
  id                 String    @id @default(uuid())
  name               String
  description        String?
  version           Int       // Tracks the version
  previousWorkflowId String?   @unique @default(null) // Links to old workflow if updated
  previousWorkflow   Workflow? @relation("WorkflowHistory", fields: [previousWorkflowId], references: [id])
  createdById       String
  createdBy         User      @relation(fields: [createdById], references: [id])
  isActive          Boolean   @default(true)

  steps             WorkflowStep[]
  processes        ProcessInstance[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}


model WorkflowStep {
  id            String   @id @default(uuid())
  workflowId    String
  workflow      Workflow @relation(fields: [workflowId], references: [id])
  stepNumber    Int
  stepName      String
  allowParallel Boolean  @default(false) // Allows multiple approvals
  nextStepId    String?  // Nullable for dynamic workflows
  nextStep      WorkflowStep? @relation(fields: [nextStepId], references: [id])
  assignments   WorkflowAssignment[]
}

enum StepType {
  APPROVAL
  REVIEW
  RECOMMENDATION
  NOTIFICATION
}

enum ApproverType {
  USER
  ROLE
  DEPARTMENT
  UNIT
}

model WorkflowAssignment {
  id            String   @id @default(uuid())
  stepId        String
  step          WorkflowStep @relation(fields: [stepId], references: [id])
  assigneeType  AssigneeType
  assigneeId    Int
  actionType    ActionType  // Defines the work required (Approval, Recommendation, etc.)
}

enum AssigneeType {
  USER
  ROLE
  DEPARTMENT
  UNIT
}

enum ActionType {
  APPROVAL
  REVIEW
  RECOMMENDATION
  NOTIFICATION
}

model ProcessInstance {
  id             String   @id @default(uuid())
  workflowId     String
  workflow       Workflow @relation(fields: [workflowId], references: [id])
  initiatorId    Int
  initiator      User     @relation(fields: [initiatorId], references: [id])
  currentStepId  String?
  currentStep    WorkflowStep? @relation(fields: [currentStepId], references: [id])
  status         ProcessStatus @default(PENDING)
  escalationTime DateTime? // User-defined escalation time
  createdAt      DateTime  @default(now())
  updatedAt      DateTime? @updatedAt
  stepInstances  ProcessStepInstance[]
  documents      ProcessDocument[]
  qaChannels     ProcessQA[]
}

enum ProcessStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REJECTED
}

model ProcessStepInstance {
  id          String   @id @default(uuid())
  processId   String
  process     ProcessInstance @relation(fields: [processId], references: [id])
  stepId      String
  step        WorkflowStep @relation(fields: [stepId], references: [id])
  assignedTo  Int
  assignedType AssigneeType
  status      StepStatus @default(PENDING)
  comments    String?
  updatedAt   DateTime? @updatedAt
}

enum StepStatus {
  PENDING
  APPROVED
  REJECTED
  SKIPPED
}

model Escalation {
  id             String   @id @default(uuid())
  stepInstanceId String
  stepInstance   ProcessStepInstance @relation(fields: [stepInstanceId], references: [id])
  escalationType EscalationType
  triggerTime    DateTime
  status         EscalationStatus @default(PENDING)
}

enum EscalationType {
  REMINDER
  ESCALATION
  AUTO_APPROVAL
}

enum EscalationStatus {
  PENDING
  TRIGGERED
  COMPLETED
}

model ProcessTracking {
  id          String   @id @default(uuid())
  processId   String
  process     ProcessInstance @relation(fields: [processId], references: [id])
  userId      Int
  actionType  ActionType
  timestamp   DateTime @default(now())
}

enum ActionType {
  SIGNED
  REJECTED
  RECOMMENDED
  FORWARDED
}

/// ✅ **Multiple Documents in a Process**
model ProcessDocument {
  id          String   @id @default(uuid())
  processId   String
  process     ProcessInstance @relation(fields: [processId], references: [id])
  documentId  Int
  document    Document @relation(fields: [documentId], references: [id])
}

/// ✅ **Q/A Channel between Initiator and Entities**
model ProcessQA {
  id           String   @id @default(uuid())
  processId    String
  process      ProcessInstance @relation(fields: [processId], references: [id])
  stepInstanceId String
  stepInstance ProcessStepInstance @relation(fields: [stepInstanceId], references: [id])
  initiatorId  Int
  initiator    User @relation(fields: [initiatorId], references: [id])
  entityId     Int  // Can be a user, role, department, or unit
  entityType   AssigneeType
  question     String
  answer       String?
  createdAt    DateTime @default(now())
  answeredAt   DateTime?
}




